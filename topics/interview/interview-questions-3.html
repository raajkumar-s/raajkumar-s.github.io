<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Interview Questions - Part 3</title>
    <link rel="stylesheet" href="../../css/app.css">
    <link rel="stylesheet" href="interview-questions.css">
</head>

<body>
    <div id="wrapper">
        <header id="main_header">
            <div>
                <div class="logo-container">
                    <a href="/" class="rk-logo">RKTech's blog</a>
                </div>
                <div class="nav_container">
                    <nav>
                        <a href="/topics/">Topics</a>
                        <a href="/about.html">About</a>
                    </nav>
                </div>
            </div>
        </header>
        <section>
            <ul>
                <li>
                    <div>
                        <p>Variable Hoisting</p>
                        <p>Links <a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">here</a> and <a href="http://javascriptissexy.com/javascript-variable-scope-and-hoisting-explained/">here</a></p>
                    </div>
                </li>
                <li>
                    <div>
                        <p>JavaScript - quirky parts</p>
                        <p><a href="http://bonsaiden.github.io/JavaScript-Garden/">JavaScript Garden</a></p>
                    </div>
                </li>
                <li>
                    <div>
                        <p>Quirks mode, almost standards and standards mode</p>
                        <p>
                            <a href="https://developer.mozilla.org/en-US/docs/Quirks_Mode_and_Standards_Mode">MDN</a>
                        </p>
                    </div>
                </li>
                <li>
                    <div>
                        <p>Many interview questions on JS, HTML, CSS and more</p>
                        <p><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions">On GitHub</a></p>
                    </div>
                </li>
                <li>
                    <div>
                        <p>Interviewing a front-end developer</p>
                        <p><a href="http://blog.sourcing.io/interview-questions">sourcing.io</a></p>
                    </div>
                </li>
                <li>
                    <div>
                        <p>Difference between <code>obj.prop = undefined</code> and <code>delete obj.prop</code></p>
                        <ul>
                            <li>
                                Setting the property of an object to <code>undefined</code> does not remove the property from the object. The porperty still exist in the object and so in the memory. <code>obj.hasOwnProperty("prop")</code> will return
                                <code>true</code>
                            </li>
                            <li>
                                But deleting a property removes it from the object and from the memory. obj.hasOwnProperty("prop") will return <code>false</code>.
                            </li>
                            <li>
                                Incase of inherited object, <code>delete</code> operator can delete only the property which is the own property of the object. It cannot delete the properties which are in the prototype.
                                <div class="sample">
                                    <samp>
                                        <pre class="linenumers">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre>
                                    <pre>
function Parent() {
    this.prop = 'parent property';
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

function Child() {
    this.prop = 'child property';          // overriding 'prop'
}                                    

var obj = new Child();

console.log(obj.prop);                     // 'child property'

obj.prop = undefined;
console.log(obj.prop);                     // undefined

delete obj.prop;
console.log(a.x);                         // 'parent property'
</pre>
                                    <div class="clearfix"></div>
                                </samp>
                                </div>
                            </li>
                        </ul>
                    </div>
                </li>
                <!--    Do not change this ID. It's lined to github. Change it only after updating in github   -->
                <li id="function_curry">
                    <div>
                        <p>Function Currying</p>
                        <div class="sample">
                            <samp>
                                <pre class="linenumers">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre>
                                <pre>
function add(a,b,c) {

  if (a == undefined && b == undefined && c == undefined) {
    return add;
  }

  else if (b == undefined && c == undefined) {
    return function(b, c) {
      return add(a,b,c);
    }
  }

  else if (c == undefined) {
    return function(c) {
      return add(a,b,c);
    }
  }

  else {
    return (a+b+c);
  }
}

var f1 = add();

console.log(f1(2)()()()(3) ()()(6));        // 11
                        </pre>
                                <div class="clearfix"></div>
                            </samp>
                        </div>
                    </div>
                </li>
                <li>
                    <p>OOPS Concepts</p>
                    <div>
                        The four important aspects of OOPS
                        <ul>
                            <li>
                                <h3>Inheritance</h3>
                                <p>
                                    Inheritance is when an object or class is based on another object (prototypal inheritance) or class (class-based inheritance), using the same implementation (inheriting from an object or class) specifying implementation to maintain the same behavior.
                                </p>
                                <figure>
                                    <img src="../../assets/images/inheritance.png">
                                    <figcaption>Father - Son bond</figcaption>
                                </figure>
                                <p>
                                    Above shown image is a simple example of inheritance. Father lion is the base and cub is derived from base. Cub will have some/all the properties of father lion and the cub will have properties of it's own.
                                </p>
                            </li>
                            <li>
                                <h3>Abstraction</h3>
                                <p>
                                    Through the process of abstraction, a programmer hides all but the relevant data about an object in order to reduce complexity and increase efficiency. Abstraction hides the internal complexity of the implementation and just exposes the interface to the developer. Developer doesn't need to be aware those internal implementation of the functionality (interface). In simple terms show functionality and hide complexity is what achieved in abstraction. Developer just uses the interface and gets the work done.
                                </p>
                                <figure>
                                    <img src="../../assets/images/articles/abstraction.jpg">
                                    <figcaption>A battery breakup</figcaption>
                                </figure>
                                <p>
                                    Consider the above example of battery. A small battery has complex internals like tin-plate bottom, metal top, anode, etc., But a consumer has little or no awareness about these internals. Cousumer buys the battery and he/she can use the battery where ever the interface is supported.
                                </p>
                            </li>
                            <li>
                                <h3>Encapsulation</h3>
                                <p>
                                    Encapsulation is the technique of making the fields in a class private and providing access to the fields via public methods. If a field is declared private, it cannot be accessed by anyone outside the class, thereby hiding the fields within the class. Data can only be manipulated by the accessor or similar methods.
                                </p>
                                <figure>
                                    <img src="../../assets/images/articles/encapsulation.png">
                                    <figcaption>Encapsulation</figcaption>
                                </figure>
                                <p>
                                    A simple for this will be a capsule, where the bitter medicine is hidden inside the capsule. Person just takes the capsule and once the capsule reached stomach it opens up and does it's work.
                                </p>
                                <p>
                                    Why not public fields?? Declaring a public is easier to access from outside the class. Since the data will directly written to the fields, we can't have any control over the validation and other manipulation data.
                                </p>
                            </li>
                            <li>
                                <h3>Polymorphism</h3>
                                <p>
                                    Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object. Any Java object that can pass more than one IS-A test is considered to be polymorphic.
                                </p>
                                <!-- Example: In EzSign I used a common Parent 'Media' is used to reference all the children which are inherited from it like 'Window', 'Image', 'Text', 'Video', 'Audio' etc., -->
                                <figure>
                                    <img src="../../assets/images/articles/polymorphism.jpg">
                                    <figcaption>Polymorphism</figcaption>
                                </figure>
                                <p>
                                    Method <strong>overloading</strong> would be an example of <strong>static polymorphism</strong>. whereas <strong>overriding</strong> would be an example of <strong>dynamic polymorphism</strong>. Because, in case of overloading, at compile time the compiler knows which method to link to the call. However, it is determined at runtime for dynamic polymorphism.
                                </p>
                            </li>
                        </ul>
                    </div>
                </li>
                <li>
                    <p>IS-A</p>
                    <p>Class <code>A</code> is the super-class of class <code>B</code>. So class <code>B IS-A</code> subclass of <code>A</code></p>
                    <p>For example <code>Sales</code> IS-A <code>Department</code></p>
                </li>
                <li>
                    <p>HAS-A</p>
                    <p>Class <code>A</code> contains a member field class <code>B</code>. So class <code>A HAS</code> class <code>B</code></p>
                    <p>For example <code>Company</code> HAS-A <code>Department</code></p>
                </li>
                <li>
                    <p>Widening/Upcasting/Generalization</p>
                    <p>Moving <strong>up</strong> in the <code>inheritance chain</code> is narrowing</p>
                </li>
                <li>
                    <p>Narrowing/Downcasting/Specalization</p>
                    <p>Moving <strong>down</strong> in the <code>inheritance chain</code> is narrowing</p>
                </li>
            </ul>
        </section>
    </div>
</body>

</html>